广播方式

设备A——advertiser（广播者），设备B——scanner或者observer（扫描者）
开发者调用 send(0x53)
首先，它没有考虑用哪一个射频信道来进行传输
send(0x53)再调用 send_LL(0x53,2402M)（注：2402M为信道频率）

这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入access address概念，用来指明接收者身份，
其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为连接），
即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，
那么就必须生成一个独特的随机access address以标识设备A和设备B两者之间的连接。

广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，
因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，

为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。

LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。
同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。
这样，整个空中包就变成（注：空中包用小端模式表示！）：

 上面这个数据包还有如下问题：

没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。
LL header用来表示数据包的LL类型，长度字节用来指明payload的长度

设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；
同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，
即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。

当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，
GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），
05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，
只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），
0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。
最终空中传输的数据包将变成：

AAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2
AA – 前导帧(preamble)
D6BE898E – 访问地址(access address)
60 – LL帧头字段(LL header)
0E – 有效数据包长度(payload length)
3B75AB2A02E1 – 广播者设备地址(advertiser address)
02010504FF590053 – 广播数据
8EC7B2 – CRC24值


有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：

无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）
由于不支持组包和拆包，因此无法传输大数据
通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。
扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。
而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。
